#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
use List::Util;
use List::MoreUtils;

my $CURRENT_VERSION = '1.06';

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------
my $usage = "

Synopsis:

gvf_validator file1.gvf

Description:

A GVF validation tool provided by the Sequence Ontology.

Options:

  --so_file, s so.obo

    A Sequence Ontology file in OBO format to use for validating SO Terms.

  --version, v 1.06

    The version of the GVF spec to validate.  Default is $CURRENT_VERSION.

  --fatal, f

    Maker errors fatal.

";

my ($help, $so_file, $version, $fatal);
my $opt_success = GetOptions('help|h'      => \$help,
			     'so_file|s=s' => \$so_file,
			     'version|v=s' => \$version,
			     'fatal|f'     => \$fatal,
			    );

if (! $opt_success) {
    print STDERR join ' : ', ('FATAL',
                              'command_line_parse_error',
                              'Use gff_tool --help to see correct usage');
}

if ($help) {
 print $usage;
 exit(0);
}

my $file = shift;

die $usage unless $file;

validate_gvf($file, $so_file);

#-----------------------------------------------------------------------------
#-------------------------------- SUBROUTINES --------------------------------
#-----------------------------------------------------------------------------

sub validate_gvf {

  my ($gvf_file, $so_file) = @_;

  my ($so_data) = parse_so_file();

  ## TODO
  my %term_sets = (alteration => 'SO:0001059',
		   effect     => 'SO:0001060',
		   feature    => 'SO:0000110',
		  );
  my %relationships = ('is_a' => 1);

  # Get valid terms
  my %valid_terms;
  no warnings;
  for my $set (keys %term_sets) {
    my $root = $term_sets{$set};
    my $these_terms = {$root => 1};
    my $seen = {};
    ($seen, $these_terms) = get_so_children($so_data, $root, \%relationships,
					    $seen, $these_terms);
    $valid_terms{$set} = $these_terms;
  }
   use warnings;

  handle_message('INFO', 'validating_GVF_file', $file);
  open(my $IN, '<', $file) or
    handle_message('FATAL', 'cant_open_file_for_reading', $file);

  my $line_count;
  my %PRAGMAS;
  my %ERRORS;
  my @stack;

  # Grab the first line;
  my $line = <$IN>;
  $line_count++;

  # Skip the first line if it's gff-version pragma.
  if ($line =~ /##gff-version\s+3/) {
    $line = <$IN>;
  $line_count++;
  }

  # Catpure and validate the gvf-version pragma.
  if ($line =~ /^\#\#gvf-version\s+(1\.\d+)$/) {
    $PRAGMAS{'gvf-version'} = $1;
    if ($version && $version ne $PRAGMAS{'gvf-version'}) {
      my $error_code = 'version_option_overiding_gvf_version_pragma';
      $ERRORS{$error_code}++;
      handle_message('WARN', $error_code,
		     '--version $version, $line');
    }
  }
  else {
    my $error_code = 'missing_required_gvf-version_pragma';
    $ERRORS{$error_code}++;
    handle_message('ERROR', $error_code,
		   "Assuming this file is \#\#gvf-version $CURRENT_VERSION for validation");
    $PRAGMAS{'gvf-version'} = $CURRENT_VERSION;
    push @stack, $line;
    $line_count--;
  }

  my $Variant_seq_regex = qr/^([A-DGHKMNR-WY]+| # Any valid IUPAC Nucleotide
			     ~\d*|            # A ~ optionally followed by an integer
			     [.\-!^\*]        # Any [.-!^*]
			    )$/ix;
  my $Reference_seq_regex = qr/^([A-DGHKMNR-WY]+|~\d*|[.\-])$/i;

 LINE:
  while ($line = shift @stack || <$IN>) {
    chomp $line;
    $line_count++;
    next LINE if $line =~ /^\s*$/;
    next LINE if $line =~ /^\#([^\#]|$)/;
    # Features
    if ($line !~ /^\#/) {
      # There must by tabs
      if ($line !~ /\t/) {
	my $error_code = 'invalid_feature_line_not_tab_delimited';
	$ERRORS{$error_code}++;
	handle_message('ERROR', $error_code, $line);
      }
      my @columns = split /\t/, $line;
      if (scalar @columns != 9) {
	my $error_code = 'invalid_feature_line_must_have_nine_columns';
	$ERRORS{$error_code}++;
	handle_message('ERROR', $error_code, $line);
      }
      my ($seqid, $source, $type, $start, $end, $score, $strand,
	  $phase, $att_text) = @columns;
      # Seqid Characters
      if ($seqid =~ /[^(a-zA-Z0-9\.:\^\*\$@!\+_\?\-\|)]/ ||
	  $seqid =~ /\s/ ||
	  $seqid =~ /^>/) {
	my $error_code = 'invalid_characters_in_seqid_column';
	$ERRORS{$error_code}++;
	handle_message('ERROR', $error_code, "($1) $line");
      }
      # Seqid and sequence-region (If you have sequence-regions you should have them for all seqids)
      if ($PRAGMAS{'sequence-region'} && ! $PRAGMAS{'sequence-region'}{$seqid}) {
	my $error_code = 'seqid_column_with_no_associated_sequence_region';
	$ERRORS{$error_code}++;
	handle_message('WARN', $error_code, $line);
      }
      # Type
      my $type_id = $so_data->{map}{$type} unless $type =~ /^SO:\d+$/;
      if ($valid_terms{alteration} &&
	  ! $valid_terms{alteration}{$type_id}) {
	my $error_code = 'invalid_type_column_must_be_SO_sequence_alteration_term_or_ID';
	$ERRORS{$error_code}++;
	handle_message('ERROR', $error_code, $line);
      }
      # Start
      if (! is_integer($start)) {
	my $error_code = 'invalid_start_column_must_be_integer';
	$ERRORS{$error_code}++;
	handle_message('ERROR', $error_code, $line);
      }
      # Start bounds checking
      if ($PRAGMAS{'sequence-region'} &&
	  $PRAGMAS{'sequence-region'}{$seqid} &&
	  ($start < $PRAGMAS{'sequence-region'}{$seqid}[0] ||
	   $start > $PRAGMAS{'sequence-region'}{$seqid}[1])) {
	my $error_code = 'invalid_start_not_contained_within_sequence_region';
	$ERRORS{$error_code}++;
	handle_message('WARN', $error_code, $line);
      }
      # End
      if (! is_integer($end)) {
	my $error_code = 'invalid_end_column_must_be_integer';
	$ERRORS{$error_code}++;
	handle_message('ERROR', $error_code, $line);
	# Do bounds checking if sequence-region
      }
      # End bounds checking
      if ($PRAGMAS{'sequence-region'} &&
	  $PRAGMAS{'sequence-region'}{$seqid} &&
	  ($end < $PRAGMAS{'sequence-region'}{$seqid}[0] ||
	   $end > $PRAGMAS{'sequence-region'}{$seqid}[1])) {
	my $error_code = 'invalid_end_not_contained_within_sequence_region';
	$ERRORS{$error_code}++;
	handle_message('WARN', $error_code, $line);
      }
      # Start less than end
      if ($start > $end) {
	my $error_code = 'invalid_feature_coordinates_start_is_greater_than_end';
	$ERRORS{$error_code}++;
	handle_message('ERROR', $error_code, $line);
      }
      # Score
      if ($score ne '.' && ! is_real_number($score)) {
	my $error_code = 'invalid_score_column_must_be_real_number';
	$ERRORS{$error_code}++;
	handle_message('ERROR', $error_code, $line);
      }
      # Strand
      if ($strand  !~ /^[\.\-+\?]$/) {
	my $error_code = 'invalid_strand_column';
	$ERRORS{$error_code}++;
	handle_message('ERROR', $error_code, $line);
      }
      # Phase
      if ($phase  ne '.') {
	my $error_code = 'invalid_character_in_phase_column';
	$ERRORS{$error_code}++;
	handle_message('ERROR', $error_code, $line);
      }

      # Attributes
      my %attributes;
      my @pairs = split /;/, $att_text;
    PAIR:
      for my $pair (@pairs) {
	if ($pair !~ /(=)/) {
	  my $error_code = 'attribute_key_value_pairs_must_be_separated_by_equal_sign';
	  $ERRORS{$error_code}++;
	  handle_message('ERROR', $error_code, "($pair) $line");
	  next PAIR;
	}
	my ($key, $value) = split /=/, $pair;
	if (! defined $key || ! defined $value) {
	  my $error_code = 'attribute_key_value_pairs_must_have_key_and_value';
	  $ERRORS{$error_code}++;
	  handle_message('ERROR', $error_code, $line);
	  next PAIR;
	}
	my @values = split /,/, $value;
	push @{$attributes{$key}}, @values;
      }
      for my $key (sort keys %attributes) {
	my @values = @{$attributes{$key}};
	# ID
	if ($key eq 'ID') {
	  if (scalar @values > 1) {
	    my $error_code = 'invalid_ID_attribute_multiple_values';
	    $ERRORS{$error_code}++;
	    my $all_ids = join ' ', @values;
	    handle_message('ERROR', $error_code, "($all_ids) $line");
	  }
	}
	# Name
	elsif ($key eq 'Name') {
	  # No validation on Name values
	}
	# Alias
	elsif ($key eq 'Alias') {
	  # No validation on Alias values
	}
	# Parent
	elsif ($key eq 'Parent') {
	    my $error_code = 'Parent_attribute_in_GVF';
	    $ERRORS{$error_code}++;
	    handle_message('WARN', $error_code, "Please contact song-devel\@lists.sourceforge.net for Parent attribute support in GVF: $line ");
	}
	# Target
	elsif ($key eq 'Target') {
	    my $error_code = 'Target_attribute_in_GVF';
	    $ERRORS{$error_code}++;
	    handle_message('WARN', $error_code, "Target attribute doesn't make sense in GVF: $line ");
	}
	# Gap
	elsif ($key eq 'Gap') {
	    my $error_code = 'Gap_attribute_in_GVF';
	    $ERRORS{$error_code}++;
	    handle_message('WARN', $error_code, "Gap attribute doesn't make sense in GVF: $line ");
	}
	# Derives_from
	elsif ($key eq 'Derives_from') {
	    my $error_code = 'Derives_from_attribute_in_GVF';
	    $ERRORS{$error_code}++;
	    handle_message('WARN', $error_code, "Please contact song-devel\@lists.sourceforge.net for Derives_from attribute support in GVF: $line ");
	}
	# Note
	elsif ($key eq 'Note') {
	  # No validation on Note value
	}
	# Dbxref
	elsif ($key eq 'Dbxref') {
	  for my $value (@values) {
	    my ($db, $ID) = split /:/, $value;
	    # TODO: Validate the Dbxref DB and ID;
	  }
	}
	# Ontology_term
	elsif ($key eq 'Ontology_term') {
	    my $error_code = 'Ontology_term_attribute_in_GVF';
	    $ERRORS{$error_code}++;
	    handle_message('WARN', $error_code, "Please contact song-devel\@lists.sourceforge.net for Ontology_term attribute support in GVF: $line ");
	}
	# Is_circular
	elsif ($key eq 'Is_circular') {
	    my $error_code = 'Is_circular_attribute_in_GVF';
	    $ERRORS{$error_code}++;
	    handle_message('WARN', $error_code, "Is_circular attribute doesn't make sense in GVF: $line ");
	}
	# Variant_seq
	elsif ($key eq 'Variant_seq') {
	  for my $value (@values) {
	    # TODO: Validate the length of the Variant_seq
	    # Compile regex once above
	    # my $Variant_seq_regex = qr/[A-DGHKMNR-WY]+| # Any valid IUPAC Nucleotide
	    # 			       ~\d*|            # A ~ optionally followed by an integer
	    # 			       [.\-!^\*]        # Any of [.-!^*]
	    # 			      /x;
	    if ($value =~ $Variant_seq_regex) {
	      if ($type eq 'SNV') {
		# A single nt or .!^*
		if ($value !~ /^([A-DGHKMNR-WY]|[.!^\*])$/i) {
		  my $error_code = 'invalid_Variant_seq_attribute_value_for_SNV';
		  $ERRORS{$error_code}++;
		  handle_message('WARN', $error_code, "($value) $line");
		}
	      }
	      # A nt string or .!^*
	      elsif ($type eq 'insertion') {
		if ($value !~ /^([A-DGHKMNR-WY]+|~\d*|[.!^\*-])$/i) {
		  my $error_code = 'invalid_Variant_seq_attribute_value_for_insertion';
		  $ERRORS{$error_code}++;
		  handle_message('WARN', $error_code, "($value) $line");
		}
	      }
	      # Any of .!^-
	      elsif ($type eq 'deletion') {
		if ($value !~ /^([A-DGHKMNR-WY]+|~\d*|[\.\^!-])$/i) {
		  my $error_code = 'invalid_Variant_seq_attribute_value_for_deletion';
		  $ERRORS{$error_code}++;
		  handle_message('WARN', $error_code, "($value) $line");
		}
	      }
	      # A nt string or .!^*-
	      elsif ($type eq 'indel') {
		if ($value !~ /^([A-DGHKMNR-WY]+|~\d*|[.\-!^])$/i) {
		  my $error_code = 'invalid_Variant_seq_attribute_value_for_indel';
		  $ERRORS{$error_code}++;
		  handle_message('WARN', $error_code, "($value) $line");
		}
	      }
	    }
	    else {
	      my $error_code = 'invalid_Variant_seq_attribute_value';
	      $ERRORS{$error_code}++;
	      handle_message('WARN', $error_code, "($value) $line");
	    }
	  }
	}
	# Reference_seq
	elsif ($key eq 'Reference_seq') {
	  for my $value (@values) {
	    if ($value =~ $Reference_seq_regex) {
	      if ($type eq 'SNV') {
		if ($value !~ /^([A-DGHKMNR-WY]+|\.)$/) {
		  my $error_code = 'invalid_Reference_seq_attribute_value_for_SNV';
		  $ERRORS{$error_code}++;
		  handle_message('WARN', $error_code, "($value) $line");
		}
	      }
	      elsif ($type eq 'insertion') {
		if ($value ne '-') {
		  my $error_code = 'invalid_Reference_seq_attribute_value_insertion';
		  $ERRORS{$error_code}++;
		  handle_message('WARN', $error_code, "($value) $line");
		}
	      }
	      elsif ($type eq 'deletion') {
		if ($value !~ /^([A-DGHKMNR-WY]+|[\.~])$/) {
		  my $error_code = 'invalid_Reference_seq_attribute_value_deletion';
		  $ERRORS{$error_code}++;
		  handle_message('WARN', $error_code, "($value) $line");
		}
	      }
	      elsif ($type eq 'indel') {
		if ($value !~ /^([A-DGHKMNR-WY]+|[\.\-~])$/) {
		  my $error_code = 'invalid_Reference_seq_attribute_value_indel';
		  $ERRORS{$error_code}++;
		  handle_message('WARN', $error_code, "($value) $line");
		}
	      }
	    }
	    else {
	      my $error_code = 'invalid_Reference_seq_attribute_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($value) $line");
	    }
	  }
	}
	# Variant_reads
	elsif ($key eq 'Variant_reads') {
	  for my $value (@values) {
	    if (! is_integer($value)) {
	      my $error_code = 'invalid_Variant_reads_attribute_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($value) $line");
	    }
	  }
	}
	# Total_reads
	elsif ($key eq 'Total_reads') {
	  if (scalar @values > 1) {
			    my $error_code = 'invalid_Total_reads_attribute_multiple_values';
			    $ERRORS{$error_code}++;
			    my $all_values = join ' ', @values;
			    handle_message('ERROR', $error_code, "($all_values) $line");
			  }
	  my $value = $values[0];
	  if (! is_integer($value)) {
	    my $error_code = 'invalid_Total_reads_attribute_value';
	    $ERRORS{$error_code}++;
	    handle_message('ERROR', $error_code, "($value) $line");
	  }
	}
	# Zygosity
	elsif ($key eq 'Zygosity') {
	  for my $value (@values) {
	    if ($value !~ /^(hetero|homo|hemi)zygous$/) {
	      my $error_code = 'invalid_Zygosity_attribute_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($value) $line");
	    }
	  }
	}
	# Variant_freq
	elsif ($key eq 'Variant_freq') {
	  for my $value (@values) {
	    if (! is_real_number($value)) {
	      my $error_code = 'invalid_Variant_freq_attribute_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($value) $line");
	    }
	  }
	}
	# Variant_effect
	elsif ($key eq 'Variant_effect') {
	  for my $value (@values) {
	    my ($sequence_variant, $index, $sequence_feature, @featureIDs) = split /\s+/, $value;
	    # TODO: Validate $sequence_variant
	    if (! is_integer($index) || $index > (scalar @{$attributes{Variant_seq}} - 1)) {
	      my $error_code = 'invalid_Variant_effect_attribute_index_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($index) $line");
	    }
	    my $seq_var_id = $so_data->{map}{$sequence_variant} unless $sequence_variant =~ /^SO:\d+$/;
	    if (! $seq_var_id || ! $valid_terms{effect}{$seq_var_id}) {
	      my $error_code = 'invalid_Variant_effect_attribute_seq_var_id_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($sequence_variant) $line");
	    }
	    my $seq_feat_id = $so_data->{map}{$sequence_feature} unless $sequence_feature =~ /^SO:\d+$/;
	    if (! $seq_feat_id || ! $valid_terms{feature}{$seq_feat_id}) {
	      my $error_code = 'invalid_Variant_effect_attribute_seq_feat_id_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($sequence_feature) $line");
	    }
	  # TODO: Validate featureIDs
	  }
	}
	# Start_range
	elsif ($key eq 'Start_range') {
	  if (scalar @values != 2) {
	    my $error_code = 'invalid_Start_range_attribute_must_have_2_values';
	    $ERRORS{$error_code}++;
	    my $all_values = join ',', @values;
	    handle_message('ERROR', $error_code, "($all_values) $line");
	  }
	  if (is_integer($values[0]) && $values[0] > $start) {
	    my $error_code = 'invalid_Start_range_attribute_values_must_contain_start';
	    $ERRORS{$error_code}++;
	    my $all_values = join ',', @values;
	    handle_message('ERROR', $error_code, "($all_values, $start) $line");
	  }
	  if (is_integer($values[1]) && $values[1] < $start) {
	    my $error_code = 'invalid_Start_range_attribute_values_must_contain_start';
	    $ERRORS{$error_code}++;
	    my $all_values = join ',', @values;
	    handle_message('ERROR', $error_code, "($all_values, $start) $line");
	  }
	  for my $value (@values) {
	    if ($value ne '.' && ! is_integer($value)) {
	      my $error_code = 'invalid_Start_range_attribute_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($value) $line");
	    }
	  }
	}
	# End_range
	elsif ($key eq 'End_range') {
	  if (scalar @values != 2) {
	    my $error_code = 'invalid_End_range_attribute_must_have_2_values';
	    $ERRORS{$error_code}++;
	    my $all_values = join ',', @values;
	    handle_message('ERROR', $error_code, "($all_values) $line");
	  }
	  if (is_integer($values[0]) && $values[0] > $end) {
	    my $error_code = 'invalid_End_range_attribute_values_must_contain_end';
	    $ERRORS{$error_code}++;
	    my $all_values = join ',', @values;
	    handle_message('ERROR', $error_code, "($all_values, $end) $line");
	  }
	  if (is_integer($values[1]) && $values[1] < $end) {
	    my $error_code = 'invalid_End_range_attribute_values_must_contain_end';
	    $ERRORS{$error_code}++;
	    my $all_values = join ',', @values;
	    handle_message('ERROR', $error_code, "($all_values, $end) $line");
	  }
	  for my $value (@values) {
	    if ($value ne '.' && ! is_integer($value)) {
	      my $error_code = 'invalid_End_range_attribute_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($value) $line");
	    }
	  }
	}
	# Phased
	elsif ($key eq 'Phased') {
	  if (scalar @values > 1) {
	    my $error_code = 'invalid_Phased_attribute_multiple_values';
	    $ERRORS{$error_code}++;
	    my $all_values = join ' ', @values;
	    handle_message('ERROR', $error_code, "($all_values) $line");
	  }
	  my $value = $values[0];
	  # TODO: Validate the Phased attribute
	}
	# Genotype
	elsif ($key eq 'Genotype') {
	  for my $value (@values) {
	    if ($value !~ /^\d+:\d+$/) {
	      my $error_code = 'invalid_Genotype_attribute_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($value) $line");
	    }
	  }
	}
	# Individual
	elsif ($key eq 'Individual') {
	  for my $value (@values) {
	    if (! is_integer($value)) {
	      my $error_code = 'invalid_Individual_attribute_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($value) $line");
	    }
	  }
	}
	# Variant_copy_number
	elsif ($key eq 'Variant_copy_number') {
	  for my $value (@values) {
	    if (! is_integer($value)) {
	      my $error_code = 'invalid_Variant_copy_number_attribute_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($value) $line");
	    }
	  }
	}
	# Reference_copy_number
	elsif ($key eq 'Reference_copy_number') {
	  if (scalar @values > 1) {
	    my $error_code = 'invalid_Reference_copy_number_attribute_multiple_values';
	    $ERRORS{$error_code}++;
	    my $all_values = join ' ', @values;
	    handle_message('ERROR', $error_code, "($all_values) $line");
	  }
	  my $value = $values[0];
	  for my $value (@values) {
	    if (! is_integer($value)) {
	      my $error_code = 'invalid_Reference_copy_number_attribute_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($value) $line");
	    }
	  }
	}
	# Variant_codon
	elsif ($key eq 'Variant_codon') {
	  for my $value (@values) {
	    if (! is_iupac_nt($value)) {
	      my $error_code = 'invalid_Variant_codon_attribute_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($value) $line");
	    }
	  }
	}
	# Reference_codon
	elsif ($key eq 'Reference_codon') {
	  for my $value (@values) {
	    if (! is_iupac_nt($value)) {
	      my $error_code = 'invalid_Reference_codon_attribute_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($value) $line");
	    }
	  }
	}
	# Variant_aa
	elsif ($key eq 'Variant_aa') {
	  for my $value (@values) {
	    if (! is_aa_sequence($value)) {
	      my $error_code = 'invalid_Variant_aa_attribute_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($value) $line");
	    }
	  }
	}
	# Reference_aa
	elsif ($key eq 'Reference_aa') {
	  for my $value (@values) {
	    if (! is_aa_sequence($value)) {
	      my $error_code = 'invalid_Reference_aa_attribute_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($value) $line");
	    }
	  }
	}
	# Breakpoint_detail
	elsif ($key eq 'Breakpoint_detail') {
	  my $value = $values[0];
	  my ($seqid, $start_end, $strand) = split /:/, $value;
	  my ($start, $end) = split /\-/, $start_end;
	  if ($PRAGMAS{'sequence-region'} && ! $PRAGMAS{'sequence-region'}{$seqid}) {
	    my $error_code = ('seqid_in_Breakpoint_detail_attribute_with_' .
			      'no_associated_sequence_region');
	    $ERRORS{$error_code}++;
	    handle_message('WARN', $error_code, $line);
	  }
	  if (! is_integer($start)) {
	    my $error_code = 'invalid_start_in_Breakpoint_detail_attribute';
	    $ERRORS{$error_code}++;
	    handle_message('WARN', $error_code, $line);
	  }
	  if ($end && ! is_integer($end)) {
	    my $error_code = 'invalid_end_in_Breakpoint_detail_attribute';
	    $ERRORS{$error_code}++;
	    handle_message('WARN', $error_code, $line);
	  }
	  if ($strand && $strand !~ /^(=|\-)$/) {
	    my $error_code = 'invalid_strand_in_Breakpoint_detail_attribute';
	    $ERRORS{$error_code}++;
	    handle_message('WARN', $error_code, $line);
	  }
	}
	# Sequence_context
	elsif ($key eq 'Sequence_context') {
	  for my $value (@values) {
	    if (! is_iupac_nt($value)) {
	      my $error_code = 'invalid_Sequence_context_attribute_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($value) $line");
	    }
	  }
	}
	# All others
	else {
	  if ($key =~ /^[A-Z]/) {
	    my $error_code = 'non_standard_attribute_must_begin_with_lowercase';
	    $ERRORS{$error_code}++;
	    handle_message('ERROR', $error_code, "($key) $line");
	  }
	}
      }
    }
    # Pragmas
    else {
      ##gvf-version pragma handled previously (around line 100)
      ##FASTA
      if ($line =~ /^\#\#FASTA/) {
	#TODO: Validate FASTA
	last LINE;
      }
      ##sequence-region
      elsif ($line =~ /^\#\#sequence-region/) {
	if ($line =~ /^\#\#(sequence-region)\s+(\S+)\s+(\d+)\s+(\d+)/) {
	  my $pragma_key = $1;
	  my $seqid      = $2;
	  my $start      = $3;
	  my $end        = $4;
	  if (! $seqid || ! $start || ! $end) {
	    my $error_code = 'missing_sequence-region_pragma_values';
	    $ERRORS{$error_code}++;
	    handle_message('ERROR', $error_code, $line);
	  }
	  elsif (! is_integer($start) ||
		 ! is_integer($end)   ||
		 $start > $end) {
	    my $error_code = 'invalid_sequence-region_pragma_value';
	    $ERRORS{$error_code}++;
	    handle_message('ERROR', $error_code, $line);
	  }
	  else {
	    $PRAGMAS{$pragma_key}{$seqid} = [$start, $end];
	  }
	}
      }
      ##feature-ontology
      elsif ($line =~ /^\#\#feature-ontology/) {
	if ($line =~ /^\#\#(feature-ontology)\s+(\S+)/) {
	  my $pragma_key   = $1;
	  my $pragma_value = $2;
	  $PRAGMAS{$pragma_key} = $pragma_value;
	  # TODO: test_uri($pragma_value);
	}
	else {
	  my $error_code = 'invalid_feature-ontology_pragma_format';
	  $ERRORS{$error_code}++;
	  handle_message('ERROR', $error_code, $line);
	}
      }
      ##attribute-ontology
      elsif ($line =~ /^\#\#attribute-ontology/) {
	if ($line =~ /^\#\#(attribute-ontology)\s+(\S+)/) {
	  my $pragma_key   = $1;
	  my $pragma_value = $2;
	  $PRAGMAS{$pragma_key} = $pragma_value;
	  #TODO: test_uri($pragma_value);
	}
	else {
	  my $error_code = 'invalid_attribute-ontology_pragma_format';
	  $ERRORS{$error_code}++;
	  handle_message('ERROR', $error_code, $line);
	}
      }
      ##source-ontology
      elsif ($line =~ /^\#\#source-ontology/) {
	if ($line =~ /^\#\#(source-ontology)\s+(\S+)/) {
	  my $pragma_key   = $1;
	  my $pragma_value = $2;
	  $PRAGMAS{$pragma_key} = $pragma_value;
	  #TODO: test_uri($pragma_value);
	}
	else {
	  my $error_code = 'invalid_source-ontology_pragma_format';
	  $ERRORS{$error_code}++;
	  handle_message('ERROR', $error_code, $line);
	}
      }
      ##species
      elsif ($line =~ /^\#\#species/) {
	if ($line =~ /^\#\#(species)\s+(\S+)/) {
	  my $pragma_key   = $1;
	  my $pragma_value = $2;
	  $PRAGMAS{$pragma_key} = $pragma_value;
	  # TODO: test_uri($pragma_value);
	}
	else {
	  my $error_code = 'invalid_species_pragma_format';
	  $ERRORS{$error_code}++;
	  handle_message('ERROR', $error_code, $line);
	}
      }
      ##genome-build
      elsif ($line =~ /^\#\#genome-build/) {
	if ($line =~ /^\#\#(genome-build)\s+(\S+)\s+(\S+)/) {
	  my $pragma_key = $1;
	  my $source     = $2;
	  my $build_name = $3;
	  $PRAGMAS{$pragma_key} = [$source, $build_name];
	}
	else {
	  my $error_code = 'invalid_genome-build_pragma_format';
	  $ERRORS{$error_code}++;
	  handle_message('ERROR', $error_code, $line);
	}
      }
      ##reference-fasta
      elsif ($line =~ /^\#\#reference-fasta/) {
	if ($line =~ /^\#\#(reference-fasta)\s+(\S+.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
          $PRAGMAS{$pragma_key} = $pragma_value;
	  #TODO: validate file
        }
        else {
          my $error_code = 'invalid_reference-fasta_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##feature-gff3
      elsif ($line =~ /^\#\#feature-gff3/) {
	if ($line =~ /^\#\#(feature-gff3)\s+(\S+.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
          $PRAGMAS{$pragma_key} = $pragma_value;
	  #TODO: validate file
        }
        else {
          my $error_code = 'invalid_feature-gff3_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##file-version
      elsif ($line =~ /^\#\#file-version/) {
	if ($line =~ /^\#\#(file-version)\s+(\S+)/) {
	  my $pragma_key = $1;
	  my $version    = $2;
	  $PRAGMAS{$pragma_key} = $version;
	}
	else {
	  my $error_code = 'invalid_file-version_pragma_format';
	  $ERRORS{$error_code}++;
	  handle_message('ERROR', $error_code, "$line");
	}
      }
      ##file-date
      elsif ($line =~ /^\#\#file-date/) {
	if ($line =~ /^\#\#(file-date)\s+(20[1-9][0-9]-\d\d-\d\d)/) {
	  my $pragma_key = $1;
	  my $date       = $2;
	  $PRAGMAS{$pragma_key} = $date;
	}
	else {
	  my $error_code = 'invalid_file-date_pragma_format';
	  $ERRORS{$error_code}++;
	  handle_message('ERROR', $error_code, "$line");
	}
      }
      ##individual-id
      elsif ($line =~ /^\#\#individual-id/) {
	if ($line =~ /^\#\#(individual-id)\s+(\S+)/) {
	  my $pragma_key   = $1;
	  my $pragma_value = $2;
	  $PRAGMAS{$pragma_key} = $pragma_value;
	}
	else {
	  my $error_code = 'invalid_individual-id_pragma_format';
	  $ERRORS{$error_code}++;
	  handle_message('ERROR', $error_code, "$line");
	}
      }
      ##population
      elsif ($line =~ /^\#\#population/) {
	if ($line =~ /^\#\#(population)\s+(.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
	  $pragma_value = [split /\s*,\s*/, $pragma_value];
	 #TODO: Validate popultaion names
        }
        else {
          my $error_code = 'invalid_population_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##sex
      elsif ($line =~ /^\#\#sex/) {
	if ($line =~ /^\#\#(sex)\s+(.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
	  my @pragma_values = split /\s*,\*/, $pragma_value;
	  for my $value (@pragma_values) {
	    if ($value !~ /^(fe)?male$/) {
	      my $error_code = 'invalid_sex_pragma_value';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($value) $line");
	    }
	    else {
	     push @{$PRAGMAS{$pragma_key}},$value;
	    }
	  }
        }
        else {
          my $error_code = 'invalid_sex_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##technology-platform-class
      elsif ($line =~ /^\#\#technology-platform-class/) {
	if ($line =~ /^\#\#(technology-platform-class)\s+(\S+.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
	  my %valid = (SRS => 1,
		       SMS => 1,
		       Capillary => 1,
		       DNA_Chip => 1);
	  if (! exists $valid{$pragma_value}) {
	    my $error_code = 'invalid_technology-platform-class_pragma_value';
	    $ERRORS{$error_code}++;
	    handle_message('ERROR', $error_code, "($pragma_value) $line");
	  }
	  else {
	    $PRAGMAS{$pragma_key} = $pragma_value;
	  }
        }
        else {
          my $error_code = 'invalid_technology-platform-class_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##technology-platform-name
      elsif ($line =~ /^\#\#technology-platform-name/) {
	if ($line =~ /^\#\#(technology-platform-name)\s+(\S+.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
	  my %valid = ('Illumina' => 1,
		       'Illumina_GA' => 1,
		       'Illumina_GAII' => 1,
		       'Illumina_GAIIx' => 1,
		       'Illumina_HiSeq' => 1,
		       'Illumina_MiSeq' => 1,
		       'SOLiD' => 1,
		       'Complete_Genomics' => 1,
		       'Ion_Torrent' => 1,
		       '454_LS' => 1,
		       'Helicos' => 1,
		       'PACBIO_RS' => 1,
		       'Affy_HS_6.0' => 1,
		       'Affy_HS_5.0' => 1,
		       'HumanOmni2.5-8' => 1,
		       'HumanOmni1S-8' => 1,
		       'HumanOmni1-Quad' => 1,
		      );
	  if (! exists $valid{$pragma_value}) {
	    my $error_code = 'invalid_technology-platform-name_pragma_value';
	    $ERRORS{$error_code}++;
	    handle_message('ERROR', $error_code, "($pragma_value) $line");
	  }
	  else {
	    $PRAGMAS{$pragma_key} = $pragma_value;
	  }
        }
        else {
          my $error_code = 'invalid_technology-platform-name_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##technology-platform-version
      elsif ($line =~ /^\#\#technology-platform-version/) {
	if ($line =~ /^\#\#(technology-platform-version)\s+(\S+.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
          $PRAGMAS{$pragma_key} = $pragma_value;
        }
        else {
          my $error_code = 'invalid_technology-platform-version_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##technology-platform-machine-id
      elsif ($line =~ /^\#\#technology-platform-machine-id/) {
	if ($line =~ /^\#\#(technology-platform-machine-id)\s+(\S+.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
          $PRAGMAS{$pragma_key} = $pragma_value;
        }
        else {
          my $error_code = 'invalid_technology-platform-machine-id_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##technology-platform-read-length
      elsif ($line =~ /^\#\#technology-platform-read-length/) {
	if ($line =~ /^\#\#(technology-platform-read-length)\s+(\S+.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
	  if (! is_integer($pragma_value)) {
	    my $error_code = 'invalid_technology-platform-read-length_pragma_value';
	    $ERRORS{$error_code}++;
	    handle_message('ERROR', $error_code, "$line");
	  }
	  else {
	    $PRAGMAS{$pragma_key} = $pragma_value;
	  }
	}
        else {
          my $error_code = 'invalid_technology-platform-read-length_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##technology-platform-read-type
      elsif ($line =~ /^\#\#technology-platform-read-type/) {
	if ($line =~ /^\#\#(technology-platform-read-type)\s+(\S+.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
	  my %valid = (fragment => 1, pair => 1);
	  if (! exists $valid{$pragma_value}) {
	    my $error_code = 'invalid_technology-platform-read-type_pragma_value';
	    $ERRORS{$error_code}++;
	    handle_message('ERROR', $error_code, "($pragma_value) $line");
	  }
	  else {
	    $PRAGMAS{$pragma_key} = $pragma_value;
	  }
        }
        else {
          my $error_code = 'invalid_technology-platform-read-type_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##technology-platform-read-pair-span
      elsif ($line =~ /^\#\#technology-platform-read-pair-span/) {
	if ($line =~ /^\#\#(technology-platform-read-pair-span)\s+(\S+.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
	  if (! is_integer($pragma_value)) {
	    my $error_code = 'invalid_technology-platform-read-pair-span_pragma_value';
	    $ERRORS{$error_code}++;
	    handle_message('ERROR', $error_code, "$line");
	  }
	  else {
	    $PRAGMAS{$pragma_key} = $pragma_value;
	  }
        }
        else {
          my $error_code = 'invalid_technology-platform-read-pair-span_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##technology-platform-average-coverage
      elsif ($line =~ /^\#\#technology-platform-average-coverage/) {
	if ($line =~ /^\#\#(technology-platform-average-coverage)\s+(\S+.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
	  if (! is_integer($pragma_value)) {
	    my $error_code =
	      'invalid_technology-platform-read-average_coverage_pragma_value';
	    $ERRORS{$error_code}++;
	    handle_message('ERROR', $error_code, "$line");
	  }
        }
        else {
          my $error_code = 'invalid_technology-platform-average-coverage_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##sequencing-scope
      elsif ($line =~ /^\#\#sequencing-scope/) {
	if ($line =~ /^\#\#(sequencing-scope)\s+(\S+.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
	  my %valid = (whole_genome  => 1,
		       whole_exome => 1,
		       targeted_capture => 1);
	  if (! exists $valid{$pragma_value}) {
	    my $error_code = 'invalid_sequencing_scope_pragma_value';
	    $ERRORS{$error_code}++;
	    handle_message('ERROR', $error_code, "($pragma_value) $line");
	  }
	  else {
	    $PRAGMAS{$pragma_key} = $pragma_value;
	  }
        }
        else {
          my $error_code = 'invalid_sequencing-scope_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##capture-method
      elsif ($line =~ /^\#\#capture-method/) {
	if ($line =~ /^\#\#(capture-method)\s+(\S+.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
	  my %valid = (TruSeq_exome      => 1,
		       TargetSeq         => 1,
		       SureSelect_exome  => 1,
		       SureSelect_custom => 1,
		       NimbleGen_exome   => 1,
		       NimbleGen_custom  => 1,
		       Other_exome       => 1,
		       Other_custom      => 1);
	  if (! exists $valid{$pragma_value}) {
	    my $error_code = 'invalid_capture_method_pragma_value';
	    $ERRORS{$error_code}++;
	    handle_message('ERROR', $error_code, "($pragma_value) $line");
	  }
	  else {
	    $PRAGMAS{$pragma_key} = $pragma_value;
	  }
        }
        else {
          my $error_code = 'invalid_capture-method_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##capture-regions
      elsif ($line =~ /^\#\#capture-regions/) {
	if ($line =~ /^\#\#(capture-regions)\s+(\S+.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
          $PRAGMAS{$pragma_key} = $pragma_value;
	  #TODO: Validate file
        }
        else {
          my $error_code = 'invalid_capture-regions_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##sequence-alignment
      elsif ($line =~ /^\#\#sequence-alignment/) {
	if ($line =~ /^\#\#(sequence-alignment)\s+(\S+.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
          $PRAGMAS{$pragma_key} = $pragma_value;
        }
        else {
          my $error_code = 'invalid_sequence-alignment_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##variant-calling
      elsif ($line =~ /^\#\#variant-calling/) {
	if ($line =~ /^\#\#(variant-calling)\s+(\S+.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
          $PRAGMAS{$pragma_key} = $pragma_value;
        }
        else {
          my $error_code = 'invalid_variant-calling_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##sample-description
      elsif ($line =~ /^\#\#sample-description/) {
	if ($line =~ /^\#\#(sample-description)\s+(\S+.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
          $PRAGMAS{$pragma_key} = $pragma_value;
        }
        else {
          my $error_code = 'invalid_sample-description_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##genomic-source
      elsif ($line =~ /^\#\#genomic-source/) {
	if ($line =~ /^\#\#(genomic-source)\s+(\S+.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
	  my %valid = (prenatal => 1, somatic => 1, germline => 1);
	  if (! exists $valid{$pragma_value}) {
	    my $error_code = 'invalid_genomic_source_pragma_value';
	    $ERRORS{$error_code}++;
	    handle_message('ERROR', $error_code, "($pragma_value) $line");
	  }
	  else {
	    $PRAGMAS{$pragma_key} = $pragma_value;
	  }
        }
        else {
          my $error_code = 'invalid_genomic-source_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ##multi-individual
      elsif ($line =~ /^\#\#multi-individual/) {
	if ($line =~ /^\#\#(multi-individual)\s+(.*)/) {
          my $pragma_key   = $1;
          my $pragma_value = $2;
	  $pragma_value = [split /\s*,\s*/, $pragma_value];
          $PRAGMAS{$pragma_key} = $pragma_value;
        }
        else {
          my $error_code = 'invalid_multi-individual_pragma_format';
          $ERRORS{$error_code}++;
          handle_message('ERROR', $error_code, "$line");
        }
      }
      ## Structured Pragmas
      ##technology-platform
      elsif ($line =~ /^\#\#technology-platform/) {
	if ($line =~ /^\#\#(technology-platform)\s+(\S+.*)/) {
	  my $pragma_key   = $1;
	  my $pragma_value = $2;
	  my @pairs = split /,/, $pragma_value;
	  for my $pair (@pairs) {
	    my ($tag, $value) = split /=/, $pair;
	    if (! defined $tag || ! defined $value) {
	      my $error_code = 'invalid_structured_pragma_tag_value_format';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($pair) $line");
	    }
	    else {
	      #Seqid
	      if ($tag eq 'Seqid') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Source
	      elsif ($tag eq 'Source') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Type
	      elsif ($tag eq 'Type') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Dbxref
	      elsif ($tag eq 'Dbxref') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Comment
	      elsif ($tag eq 'Comment') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Platform_class,
	      elsif ($tag eq 'Platform_class') {
		my %valid = (SRS       => 1,
			     SMS       => 1,
			     Capillary => 1,
			     DNA_Chip  => 1,);
		if (exists $valid{$value}) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Platform_name
	      elsif ($tag eq 'Platform_name') {
		my %valid = ('Illumina' => 1,
			     'SOLiD' => 1,
			     'Complete_Genomics' => 1,
			     'Ion_Torrent' => 1,
			     '454_LS' => 1,
			     'Helicos' => 1,
			     'PACBIO_RS' => 1,
			     'Affy_HS_6.0' => 1,
			     'Affy_HS_5.0' => 1,
			     'HumanOmni2.5-8' => 1,
			     'HumanOmni1S-8' => 1,
			     'HumanOmni1-Quad' => 1);
		if (exists $valid{$value}) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Read_length
	      elsif ($tag eq 'Read_length') {
		if (is_integer($value)) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Read_type
	      elsif ($tag eq 'Read_type') {
		my %valid = (fragment => 1, pair => 1);
		if (exists $valid{$value}) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Read_pair_span
	      elsif ($tag eq 'Read_pair_span') {
		if (is_integer($value)) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Average_coverage
	      elsif ($tag eq 'Average_coverage') {
		if (is_integer($value)) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      else {
		my $error_code = 'invalid_structured_pragma_tag';
		$ERRORS{$error_code}++;
		handle_message('ERROR', $error_code, "($tag) $line");
	      }
	    }
	  }
	}
	else {
	  my $error_code = 'invalid_technology-platform_pragma_format';
	  $ERRORS{$error_code}++;
	  handle_message('ERROR', $error_code, "$line");
	}
      }
      ##data-source
      elsif ($line =~ /^\#\#data-source/) {
	if ($line =~ /^\#\#(data-source)\s+(\S+.*)/) {
	  my $pragma_key   = $1;
	  my $pragma_value = $2;
	  my @pairs = split /,/, $pragma_value;
	  for my $pair (@pairs) {
	    my ($tag, $value) = split /=/, $pair;
	    if (! defined $tag || ! defined $value) {
	      my $error_code = 'invalid_structured_pragma_tag_value_format';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($pair) $line");
	    }
	    else {
	      #Seqid
	      if ($tag eq 'Seqid') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Source
	      elsif ($tag eq 'Source') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Type
	      elsif ($tag eq 'Type') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Dbxref
	      elsif ($tag eq 'Dbxref') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Comment
	      elsif ($tag eq 'Comment') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      # Data_type
	      elsif ($tag eq 'Data_type') {
		my %valid = (DNA_sequence   => 1,
			     RNA_sequence   => 1,
			     DNA_microarray => 1,
			     Array_CGH      => 1);
		if ($valid{$value}) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      else {
		my $error_code = 'invalid_structured_pragma_tag';
		$ERRORS{$error_code}++;
		handle_message('ERROR', $error_code, "($tag) $line");
	      }
	    }
	  }
	}
	else {
	  my $error_code = 'invalid_data-source_pragma_format';
	  $ERRORS{$error_code}++;
	  handle_message('ERROR', $error_code, "$line");
	}
      }
      ##score-method
      elsif ($line =~ /^\#\#score-method/) {
	if ($line =~ /^\#\#(score-method)\s+(\S+.*)/) {
	  my $pragma_key   = $1;
	  my $pragma_value = $2;
	  my @pairs = split /,/, $pragma_value;
	  for my $pair (@pairs) {
	    my ($tag, $value) = split /=/, $pair;
	    if (! defined $tag || ! defined $value) {
	      my $error_code = 'invalid_structured_pragma_tag_value_format';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($pair) $line");
	    }
	    else {
	      #Seqid
	      if ($tag eq 'Seqid') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Source
	      elsif ($tag eq 'Source') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Type
	      elsif ($tag eq 'Type') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Dbxref
	      elsif ($tag eq 'Dbxref') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
		#Comment
	      }
	      elsif ($tag eq 'Comment') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      else {
		my $error_code = 'invalid_structured_pragma_tag';
		$ERRORS{$error_code}++;
		handle_message('ERROR', $error_code, "($tag) $line");
	      }
	    }
	  }
	}
	else {
	  my $error_code = 'invalid_score-method_pragma_format';
	  $ERRORS{$error_code}++;
	  handle_message('ERROR', $error_code, "$line");
	}
      }
      ##source-method
      elsif ($line =~ /^\#\#source-method/) {
	if ($line =~ /^\#\#(source-method)\s+(\S+.*)/) {
	  my $pragma_key   = $1;
	  my $pragma_value = $2;
	  my @pairs = split /,/, $pragma_value;
	  for my $pair (@pairs) {
	    my ($tag, $value) = split /=/, $pair;
	    if (! defined $tag || ! defined $value) {
	      my $error_code = 'invalid_structured_pragma_tag_value_format';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($pair) $line");
	    }
	    else {
	      #Seqid
	      if ($tag eq 'Seqid') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Source
	      elsif ($tag eq 'Source') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Type
	      elsif ($tag eq 'Type') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Dbxref
	      elsif ($tag eq 'Dbxref') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Comment
	      elsif ($tag eq 'Comment') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      else {
		my $error_code = 'invalid_structured_pragma_tag';
		$ERRORS{$error_code}++;
		handle_message('ERROR', $error_code, "($tag) $line");
	      }
	    }
	  }
	}
	else {
	  my $error_code = 'invalid_source-method_pragma_format';
	  $ERRORS{$error_code}++;
	  handle_message('ERROR', $error_code, "$line");
	}
      }
      ##attribute-method
      elsif ($line =~ /^\#\#attribute-method/) {
	if ($line =~ /^\#\#(attribute-method)\s+(\S+.*)/) {
	  my $pragma_key   = $1;
	  my $pragma_value = $2;
	  my @pairs = split /,/, $pragma_value;
	  for my $pair (@pairs) {
	    my ($tag, $value) = split /=/, $pair;
	    if (! defined $tag || ! defined $value) {
	      my $error_code = 'invalid_structured_pragma_tag_value_format';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($pair) $line");
	    }
	    else {
	      #Seqid
	      if ($tag eq 'Seqid') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Source
	      elsif ($tag eq 'Source') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Type
	      elsif ($tag eq 'Type') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Dbxref
	      elsif ($tag eq 'Dbxref') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Comment
	      elsif ($tag eq 'Comment') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      else {
		my $error_code = 'invalid_structured_pragma_tag';
		$ERRORS{$error_code}++;
		handle_message('ERROR', $error_code, "($tag) $line");
	      }
	    }
	  }
	}
	else {
	  my $error_code = 'invalid_attribute-method_pragma_format';
	  $ERRORS{$error_code}++;
	  handle_message('ERROR', $error_code, "$line");
	}
      }
      ##phenotype-description
      elsif ($line =~ /^\#\#phenotype-description/) {
	if ($line =~ /^\#\#(phenotype-description)\s+(\S+.*)/) {
	  my $pragma_key   = $1;
	  my $pragma_value = $2;
	  my @pairs = split /,/, $pragma_value;
	  for my $pair (@pairs) {
	    my ($tag, $value) = split /=/, $pair;
	    if (! defined $tag || ! defined $value) {
	      my $error_code = 'invalid_structured_pragma_tag_value_format';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($pair) $line");
	    }
	    else {
	      #Seqid
	      if ($tag eq 'Seqid') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Source
	      elsif ($tag eq 'Source') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Type
	      elsif ($tag eq 'Type') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Dbxref
	      elsif ($tag eq 'Dbxref') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Comment
	      elsif ($tag eq 'Comment') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Term
	      elsif ($tag eq 'Term') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Ontology
	      elsif ($tag eq 'Ontology') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      else {
		my $error_code = 'invalid_structured_pragma_tag';
		$ERRORS{$error_code}++;
		handle_message('ERROR', $error_code, "($tag) $line");
	      }
	    }
	  }
	}
	else {
	  my $error_code = 'invalid_phenotype-description_pragma_format';
	  $ERRORS{$error_code}++;
	  handle_message('ERROR', $error_code, "$line");
	}
      }
      ##phased-genotypes
      elsif ($line =~ /^\#\#phased-genotypes/) {
	if ($line =~ /^\#\#(phased-genotypes)\s+(\S+.*)/) {
	  my $pragma_key   = $1;
	  my $pragma_value = $2;
	  my @pairs = split /,/, $pragma_value;
	  for my $pair (@pairs) {
	    my ($tag, $value) = split /=/, $pair;
	    if (! defined $tag || ! defined $value) {
	      my $error_code = 'invalid_structured_pragma_tag_value_format';
	      $ERRORS{$error_code}++;
	      handle_message('ERROR', $error_code, "($pair) $line");
	    }
	    else {
	      #Seqid
	      if ($tag eq 'Seqid') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Source
	      elsif ($tag eq 'Source') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Type
	      elsif ($tag eq 'Type') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Dbxref
	      elsif ($tag eq 'Dbxref') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      #Comment
	      elsif ($tag eq 'Comment') {
		if ($value) {
		  $PRAGMAS{$pragma_key}{tag} = $value;
		  #TODO: Validate value
		}
		else {
		  my $error_code = 'invalid_structured_pragma_value';
		  $ERRORS{$error_code}++;
		  handle_message('ERROR', $error_code, "($pair) $line");
		}
	      }
	      else {
		my $error_code = 'invalid_structured_pragma_tag';
		$ERRORS{$error_code}++;
		handle_message('ERROR', $error_code, "($tag) $line");
	      }
	    }
	  }
	}
	else {
	  my $error_code = 'invalid_phased-genotypes_pragma_format';
	  $ERRORS{$error_code}++;
	  handle_message('ERROR', $error_code, "$line");
	}
      }
      ###
      elsif ($line =~ /^\#\#\#$/) {
	# Skip ### - there's no way to further validate it.
      }
      # All other pragmas
      else {
	$line =~ /^\#\#(\S+)\s*(.*)/;
	my $pragma_key   = $1;
	my $pragma_value = $2;
	if ($pragma_key eq 'gvf-version') {
	  my $error_code = 'gvf_version_pragma_invalid_location';
	  $ERRORS{$error_code}++;
	  my $message = "##gvf-version pragma must be first (or second with ##gff-version as first) line of the file";
	  handle_message('ERROR', $error_code, $line);
	}
	else {
	  my $error_code = 'non_standard_pragma';
	  $ERRORS{$error_code}++;
	  handle_message('WARN', $error_code, $line);
	}
	$PRAGMAS{$pragma_key} = $pragma_value;
      }
    }
  }

  close $IN;
  print "\n\n";
  print "Error Summary for $file\n";
  print '#' x 80;
  print "\n";
  if (scalar keys %ERRORS) {
    print "Error Code\tCount\n";
    for my $error_code (keys %ERRORS) {
      print "$error_code\t" . $ERRORS{$error_code} . "\n";
    }
    print <<'END';

The current version of the GVF specification can be found at
http://www.sequenceontology.org/resources/gvf.html. Please contact
song-devel@lists.sourceforge.net for help with errors or to provide
feedback for improving and updating the GVF specification.

END

  }
  else {
    print "No Errors found in this file\n";
  }
  print '#' x 80;
  print "\n\n";
}

#-----------------------------------------------------------------------------

sub parse_so_file {

  $so_file = shift;

  $so_file ||= $ENV{SO_OBO};
  $so_file ||= 'curl -s http://www.sequenceontology.org/resources/obo_files/current_release.obo |';
  open (my $IN, $so_file) or handle_message('FATAL', 'cant_open_file', $so_file);


    my $text = join '', (<$IN>);

    handle_message('FATAL', 'no_SO_data_available', "$so_file (consider using --so_file or check file contents)")
      unless $text;

    $text =~ s/.*?\[Term\]/\[Term\]/s;

    my @terms_array = $text =~ /^\[Term\]\n(.*?)\n{2,}/msg;

    my %terms;
    my %map;
    my %graph;
    for my $term_text (@terms_array) {
	my %term;
	my @pairs = split /\n/, $term_text;
	for my $pair (@pairs) {
	    my ($tag, $value) = split /:\s+/, $pair;
	    push @{$term{$tag}}, $value;
	}
	my $id   = $term{id}[0];
	my $name = $term{name}[0];
	$terms{$id} = \%term;
	$map{$name} = $id;
	$map{$id}   = $name;
	$term{is_a} ||= [];
	for my $is_a (@{$term{is_a}}) {
	    my ($is_a_object) = split /\s/, $is_a;
	    $graph{$is_a_object}{is_a}{$id}++;
	}
	$term{relationship} ||= [];
	for my $relationship (@{$term{relationship}}) {
	    my ($predicate, $object) = split /\s+/, $relationship;
	    $graph{$object}{$predicate}{$id}++;
	}
    }

    my %so_data = (terms => \%terms,
		   map   => \%map,
		   graph => \%graph,
		   );

  my %parts;
  for my $id (keys %{$so_data{graph}}) {
      if (exists $so_data{graph}{$id}{part_of} || exists $so_data{graph}{$id}{member_of}) {
	  my %all_part_kids;
	  for my $part (keys %{$so_data{graph}{$id}{part_of}}, keys %{$so_data{graph}{$id}{member_of}}) {
	      my $part_kids = {};
	      my $part_seen = {};
	      map {$part_kids->{$_}++} (keys %{$so_data{graph}{$id}{part_of}}, keys %{$so_data{graph}{$id}{member_of}});
	      ($part_seen, $part_kids) = get_so_children(\%so_data, $part, {is_a => 1}, $part_seen, $part_kids);
	      map {$all_part_kids{$_}++} keys %{$part_kids};
	      print '';
	  }
	  my $whole_kids = {$id => 1};
	  my $whole_seen = {};
	  ($whole_seen, $whole_kids) = get_so_children(\%so_data, $id, {is_a => 1}, $whole_seen, $whole_kids);
	  print '';
	  for my $part (keys %all_part_kids) {
	      my $part_name = $so_data{map}{$part};
	      map {$parts{$part_name}{$so_data{map}{$_}}++} keys %{$whole_kids};
	  }
	  print '';
      }
  }
  $so_data{parts} = \%parts;

  return \%so_data;
}

#-----------------------------------------------------------------------------

sub get_so_children {

    no warnings 'recursion';
    my ($so_data, $term_id, $relationships, $seen, $children) = @_;

    $term_id = $so_data->{map}{$term_id} unless $term_id =~ /^SO:\d{7}/;
    my $term = $so_data->{terms}{$term_id};

    for my $relationship (keys %{$relationships}) {
	next unless $so_data->{graph}{$term_id}{$relationship};
	map {$children->{$_}++}
	    keys %{$so_data->{graph}{$term_id}{$relationship}};
    }

#    my %these_relationships;
#    $these_relationships{$so_data->{graph}{$term_id}{is_a}}++
#	if $relationships->{is_a};
#    my @more_relationships = @{$so_data->{graph}{$term_id}{relationships}}
#        if exists $so_data->{graph}{$term_id}{relationships};
#    for my $relationship (@more_relationships) {
#	$these_relationships{$so_data->{graph}{$term_id}{relationship}}++;
#    }
#
#    my %these_children;
#    for my $relationship (keys %these_relationships) {
#	map {$these_children{$_}++; $children->{$_}++} @{$term->{relationships}{$relationship}};
#    }


    for my $child (keys %{$children}) {
	next if $seen->{$child};
	$seen->{$child}++;
	my ($seen, $children) = get_so_children($so_data, $child,
						$relationships, $seen,
						$children);
    }
    use warnings 'recursion';
    return ($seen, $children);
}

#-----------------------------------------------------------------------------

sub handle_message {

    my ($level, $code, @comments) = @_;

    $level ||= 'FATAL';
    $code  ||= 'unknown_warning';
    my $comment = join ' ', @comments;

    my $message = join ' : ', ($level, $code, $comment);
    chomp $message;
    $message .= "\n";

    if ($level eq 'FATAL') {
      print STDERR $message;
      die;
    }
    elsif ($level eq 'ERROR') {
      print STDERR $message;
      die if $fatal;
    }
    else {
      print STDERR $message;
    }
}

#-----------------------------------------------------------------------------

sub is_real_number {

  my $value = shift;

  return 1 if $value =~ /^\d+(\.\d+(e[+\-]?\d+)?)?/i;

}

#-----------------------------------------------------------------------------

sub is_integer {

  my $value = shift;

  return 1 if $value =~ /^\d+$/;

}

#-----------------------------------------------------------------------------

sub is_iupac_nt {

  my $value = shift;

  return 1 if $value =~ /[A-DGHKMNR-WY]+/i;

}

#-----------------------------------------------------------------------------

sub is_aa_sequence {

  my $value = shift;

  return 1 if $value =~ /^[AC-IK-NP-TVWY\*]+$/i;

}

#-----------------------------------------------------------------------------

